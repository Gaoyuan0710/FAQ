---
layout: post
category: note
title: C++ API 设计（API design for C++）笔记
tagline: by 浅奕
tags: [c++]
---

## 第一章 API简介

 1. API（Application Programming Interface ）提供了对某个问题的抽象，以及客户与解决该软件问题的软件组件之间进行交互的方式。组件本身通常以软件类库的形式分发，它们可以在多个应用程序中使用。概括地说，API定义了一些可复用的模块，使得各个模块可以嵌入到最终用户的应用程序中去。

2. C++中的API通常会包含以下元素：头文件、类库、文档。

## 第二章 特性

**API的特征：**

- 问题域建模（提供良好的抽象、关键对象的建模）
- 隐藏实现的细节（物理隐藏：声明与定义，逻辑隐藏：封装，隐藏成员变量，隐藏实现方法，隐藏实现类）
- 最小完备性（不要过度承诺、谨慎添加虚函数、便捷API）
- 易用性（可发现性、不易误用、一致性（比如命名格式，参数顺序，内存模型的语义，错误处理等）、正交（函数间没有副作用）、健壮的资源分配、平台独立（接口一致））
- 松耦合（仅通过名字耦合（类的前置声明），降低类耦合（优先声明非成员、友元函数），刻意的冗余（稍微冗余两个类之间共有的功能而不是抽象出来增加耦合度），管理器类（工厂模式），回调（lamada、仿函数、闭包等等）、观察者（观察者模式）和通知（boost的信号与槽））。

**不使用public成员而使用private成员+getter和setter惯用法的原因：**

- 有效性验证（可以在setter里检查设置的值是否在许可区间里）
- 惯性求值（比如一个成员计算过于耗时，而这个类的用户（这里的用户指其他程序员）不一定需要时，可以在getter方法调用的时候再计算）
- 缓存
- 额外的操作（比如用户调用setter方法时，可以把这个值更新到配置文件里）
- 通知（其它模块可能需要在某个值发生变化的时候做一些操作，那么就可以在setter里实现）
- 调试（可以方便的打印设置日志，从而追踪错误）
- 同步（如果多线程访问需要加锁的话，setter里加锁不是很容易么）
- 更精细的权限访问（比如private变量只有getter没有setter，那客户对该变量就是只读了，而类的内部代码可以读写）
- 维护不变式关系（比如一个类内部要维持连个变量a和b有a = b * 2的关系，那么在a和b的setter里计算就能维持这样的关系）

**个人觉得还有一个：**

- 便于类升级修改（getter/setter不向类的用户保留类内部的数据结构组织方式，那么在类内部的数据结构发生改变时，无需修改使用该类的代码）

## 第三章 模式

待续...

